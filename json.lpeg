
-- **********************************************************************

local iconv      = require "org.conman.iconv"
local tcc        = require "org.conman.tcc"
local lpeg       = require "lpeg"
local re         = require "re"

local conversion = iconv.open("UTF-16LE","UTF-8")

-- **********************************************************************

local TOUTF16 = --[[ C ]] [[
#include <stddef.h>
#include <lua.h>
#include <lauxlib.h>

int toutf16(lua_State *L)
{
  size_t len;
  size_t i;

  luaL_checktype(L,1,LUA_TTABLE);
  len = lua_objlen(L,1);
  
  unsigned short input[len];

  for (i = 0 ; i < len ; i++)
  {
    lua_rawgeti(L,1,i+1);
    input[i] = lua_tointeger(L,-1);
    lua_pop(L,1);
  }
  
  lua_pushlstring(L,(char *)input,len * sizeof(short));
  return 1;
}

]]

local chunk = tcc.new()
chunk:output_type('memory')
chunk:add_string(TOUTF16)
chunk:relocate()
local toutf16 = chunk:get_symbol('toutf16')

-- **********************************************************************

local G = --[[ lpeg/re ]] [[
json		<- object /  array -> {}

object		<- begin_object
			%member_list
		   end_object
member		<- {: string name_separator value :}

array		<- begin_array
			(value (value_separator value)* )*
		   end_array

number		<- { "-" ? int frac ? exp ? } => tonumber
exp		<- [Ee] [+-] ? [0-9]+
frac		<- "." [0-9]+
int		<- "0" / ( [1-9] [0-9]* )

string		<- '"' char* -> {} => final_string '"'
char		<- unescaped	=> normal
		/ '\"'		=> escape
		/ "\\"		=> escape
		/ "\b"		=> escape
		/ "\f"		=> escape
		/ "\n"		=> escape
		/ "\r"		=> escape
		/ "\t"		=> escape
		/ "\/"		=> escape
		/ (
                    "\u"
		    { [0-9A-Fa-f]^4 }  => tou16
		  )+  -> {}            => unicode

unescaped	<- [^\"%c]

value		<- "false"	=> retfalse
		/  "null" 	=> retnil
		/  "true" 	=> rettrue
		/  object
		/  array 
		/  number 
		/  string

begin_array	<- ws "[" ws
end_array	<- ws "]" ws
begin_object	<- ws "{" ws
end_object	<- ws "}" ws
name_separator	<- ws ":" ws
value_separator	<- ws "," ws
ws		<- (%c / %s)*
]]

local member = lpeg.V"member"
local value_separator = lpeg.V"value_separator"
local member_list = lpeg.Cf(
		lpeg.Ct("") * (member * (value_separator * member)^0)^0,
		rawset
	)

-- **********************************************************************

local R =
{
  member_list = member_list,

  retnil = function(subject,position,capture)
    return position,nil
  end,

  retfalse = function(subject,position,capture)
    return position,false
  end,

  rettrue = function(subject,position,capture)
    return position,true
  end,

  tonumber = function(subject,position,capture)
    return position,tonumber(capture)
  end,

  tou16 = function(subject,position,capture)
    return position,tonumber(capture,16)
  end,

  unicode = function(subject,position,capture)
    local utf16 = toutf16(capture)
    local utf8  = conversion(utf16)
    return position,utf8
  end,
    
  normal = function(subject,position,capture)
    return position,capture
  end,

  escape = function(subject,position,capture)
    local trans = 
    { 
      [ [[\]] ] = 92,
      [ [[/]] ] = 47,
      [ [["]] ] = 34,
      b = 7 , 
      f = 12 , 
      n = 10, 
      r = 13, 
      t = 9 
    }

    return position,string.char(trans[capture:sub(2,2)])
  end,

  final_string = function(subject,position,capture)
    return position,table.concat(capture,"")
  end,

}
  
-- *********************************************************************

lpeg.setmaxstack(1000)
json = re.compile(G,R)

